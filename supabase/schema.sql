-- Enable extensions
create extension if not exists "uuid-ossp";

create table if not exists users (
  id uuid primary key references auth.users(id) on delete cascade,
  email text not null unique,
  role text not null default 'customer' check (role in ('customer', 'admin'))
);

create table if not exists products (
  id bigint generated by default as identity primary key,
  title text not null,
  price numeric(10,2) not null check (price >= 0),
  image text not null,
  description text not null,
  created_at timestamptz not null default now()
);

create table if not exists orders (
  id bigint generated by default as identity primary key,
  user_id uuid not null references users(id) on delete cascade,
  total_price numeric(10,2) not null check (total_price >= 0),
  status text not null default 'placed',
  created_at timestamptz not null default now()
);

create table if not exists cart (
  id bigint generated by default as identity primary key,
  user_id uuid not null references users(id) on delete cascade,
  product_id bigint not null references products(id) on delete cascade,
  quantity int not null default 1 check (quantity > 0)
);

alter table users enable row level security;
alter table products enable row level security;
alter table orders enable row level security;
alter table cart enable row level security;

create policy "products readable by all" on products
  for select using (true);

create policy "admins manage products" on products
  for all
  using (
    exists (
      select 1 from users where users.id = auth.uid() and users.role = 'admin'
    )
  )
  with check (
    exists (
      select 1 from users where users.id = auth.uid() and users.role = 'admin'
    )
  );

create policy "users read own profile" on users
  for select using (id = auth.uid());

create policy "users manage own cart" on cart
  for all using (user_id = auth.uid())
  with check (user_id = auth.uid());

create policy "users manage own orders" on orders
  for all using (user_id = auth.uid())
  with check (user_id = auth.uid());

create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.users (id, email, role)
  values (new.id, new.email, 'customer')
  on conflict (id) do nothing;
  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row execute procedure public.handle_new_user();
